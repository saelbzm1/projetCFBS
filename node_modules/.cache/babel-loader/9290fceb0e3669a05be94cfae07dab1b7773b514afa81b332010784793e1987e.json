{"ast":null,"code":"import along from \"@turf/along\";\nimport circle from \"@turf/circle\";\nimport length from \"@turf/length\";\nimport { lineString } from \"@turf/helpers\";\nimport { isGeofenceArray, validateCoordinates } from \"./utils\";\nconst GEOFENCE_ID_REGEX = /^[-._\\p{L}\\p{N}]+$/iu;\nexport const getGeofenceFeatureArray = data => {\n  const coordinates = isGeofenceArray(data) ? data.map(geofence => geofence.geometry.polygon) : data;\n  return {\n    type: \"Feature\",\n    geometry: {\n      type: \"MultiPolygon\",\n      coordinates\n    },\n    properties: {}\n  };\n};\nexport const getGeofenceFeatureFromPolygon = polygon => {\n  return {\n    type: \"Feature\",\n    geometry: {\n      type: \"Polygon\",\n      coordinates: polygon\n    },\n    properties: {}\n  };\n};\n// Measures distance between the coordinate bounds and takes two points 1/4 from each coordinate to create a polygon\nexport const getPolygonFeatureFromBounds = (id, bounds) => {\n  const swCoordinate = bounds.getSouthWest().toArray();\n  const neCoordinate = bounds.getNorthEast().toArray();\n  const center = bounds.getCenter().toArray();\n  const line = lineString([swCoordinate, center, neCoordinate]);\n  const distanceInMiles = length(line, {\n    units: \"miles\"\n  });\n  // Gets coordinates 1/4 along the line from each coordinate\n  const southWestCoordinate = along(line, distanceInMiles / 4, {\n    units: \"miles\"\n  }).geometry.coordinates;\n  const northeastCoordinate = along(line, distanceInMiles * (3 / 4), {\n    units: \"miles\"\n  }).geometry.coordinates;\n  // Creates a polygon from the coordinates found along the line between the bounding coordinates in counter clockwise order starting from northeast most coordinate\n  const polygon = [[northeastCoordinate, [southWestCoordinate[0], northeastCoordinate[1]], southWestCoordinate, [northeastCoordinate[0], southWestCoordinate[1]], northeastCoordinate]];\n  return {\n    id,\n    type: \"Feature\",\n    geometry: {\n      type: \"Polygon\",\n      coordinates: polygon\n    },\n    properties: {}\n  };\n};\nexport const getCircleFeatureFromCoords = (id, center, _ref) => {\n  let {\n    bounds,\n    radius\n  } = _ref;\n  if (!bounds && !radius) {\n    throw new Error(\"Circle requires a bounds or a radius\");\n  }\n  validateCoordinates(center);\n  const circleRadius = radius !== null && radius !== void 0 ? radius : getDistanceFromBounds(bounds) / 8;\n  const circleFeature = circle(center, circleRadius, {\n    units: \"miles\"\n  });\n  return {\n    id,\n    type: \"Feature\",\n    properties: {\n      isCircle: true,\n      center,\n      radius: circleRadius\n    },\n    geometry: {\n      type: \"Polygon\",\n      coordinates: circleFeature.geometry.coordinates\n    }\n  };\n};\nconst getDistanceFromBounds = bounds => {\n  const swCoordinate = bounds.getSouthWest().toArray();\n  const neCoordinate = bounds.getNorthEast().toArray();\n  const center = bounds.getCenter().toArray();\n  const line = lineString([swCoordinate, center, neCoordinate]);\n  return length(line, {\n    units: \"miles\"\n  });\n};\nexport const doesGeofenceExist = (id, loadedGeofences) => {\n  return !!loadedGeofences[id];\n};\nexport const isValidGeofenceId = id => {\n  return !!id.match(GEOFENCE_ID_REGEX);\n};\nexport const isExistingGeofenceId = (id, loadedGeofences) => {\n  return doesGeofenceExist(id, loadedGeofences);\n};\nexport const isGeofenceDisplayed = (id, displayedGeofences) => {\n  return !!displayedGeofences.find(geofence => geofence.geofenceId === id);\n};\nexport const getDistanceBetweenCoordinates = (startCoord, endCoord) => {\n  const line = lineString([startCoord, endCoord]);\n  const distanceInMiles = length(line, {\n    units: \"miles\"\n  });\n  return distanceInMiles;\n};","map":{"version":3,"names":["along","circle","length","lineString","isGeofenceArray","validateCoordinates","GEOFENCE_ID_REGEX","getGeofenceFeatureArray","data","coordinates","map","geofence","geometry","polygon","type","properties","getGeofenceFeatureFromPolygon","getPolygonFeatureFromBounds","id","bounds","swCoordinate","getSouthWest","toArray","neCoordinate","getNorthEast","center","getCenter","line","distanceInMiles","units","southWestCoordinate","northeastCoordinate","getCircleFeatureFromCoords","_ref","radius","Error","circleRadius","getDistanceFromBounds","circleFeature","isCircle","doesGeofenceExist","loadedGeofences","isValidGeofenceId","match","isExistingGeofenceId","isGeofenceDisplayed","displayedGeofences","find","geofenceId","getDistanceBetweenCoordinates","startCoord","endCoord"],"sources":["C:/Users/sael.bouzemarene/cfbsprojet/node_modules/maplibre-gl-js-amplify/lib/esm/geofenceUtils.js"],"sourcesContent":["import along from \"@turf/along\";\nimport circle from \"@turf/circle\";\nimport length from \"@turf/length\";\nimport { lineString } from \"@turf/helpers\";\nimport { isGeofenceArray, validateCoordinates } from \"./utils\";\nconst GEOFENCE_ID_REGEX = /^[-._\\p{L}\\p{N}]+$/iu;\nexport const getGeofenceFeatureArray = (data) => {\n    const coordinates = isGeofenceArray(data)\n        ? data.map((geofence) => geofence.geometry.polygon)\n        : data;\n    return {\n        type: \"Feature\",\n        geometry: {\n            type: \"MultiPolygon\",\n            coordinates,\n        },\n        properties: {},\n    };\n};\nexport const getGeofenceFeatureFromPolygon = (polygon) => {\n    return {\n        type: \"Feature\",\n        geometry: {\n            type: \"Polygon\",\n            coordinates: polygon,\n        },\n        properties: {},\n    };\n};\n// Measures distance between the coordinate bounds and takes two points 1/4 from each coordinate to create a polygon\nexport const getPolygonFeatureFromBounds = (id, bounds) => {\n    const swCoordinate = bounds.getSouthWest().toArray();\n    const neCoordinate = bounds.getNorthEast().toArray();\n    const center = bounds.getCenter().toArray();\n    const line = lineString([swCoordinate, center, neCoordinate]);\n    const distanceInMiles = length(line, { units: \"miles\" });\n    // Gets coordinates 1/4 along the line from each coordinate\n    const southWestCoordinate = along(line, distanceInMiles / 4, {\n        units: \"miles\",\n    }).geometry.coordinates;\n    const northeastCoordinate = along(line, distanceInMiles * (3 / 4), {\n        units: \"miles\",\n    }).geometry.coordinates;\n    // Creates a polygon from the coordinates found along the line between the bounding coordinates in counter clockwise order starting from northeast most coordinate\n    const polygon = [\n        [\n            northeastCoordinate,\n            [southWestCoordinate[0], northeastCoordinate[1]],\n            southWestCoordinate,\n            [northeastCoordinate[0], southWestCoordinate[1]],\n            northeastCoordinate,\n        ],\n    ];\n    return {\n        id,\n        type: \"Feature\",\n        geometry: {\n            type: \"Polygon\",\n            coordinates: polygon,\n        },\n        properties: {},\n    };\n};\nexport const getCircleFeatureFromCoords = (id, center, { bounds, radius }) => {\n    if (!bounds && !radius) {\n        throw new Error(\"Circle requires a bounds or a radius\");\n    }\n    validateCoordinates(center);\n    const circleRadius = radius !== null && radius !== void 0 ? radius : getDistanceFromBounds(bounds) / 8;\n    const circleFeature = circle(center, circleRadius, { units: \"miles\" });\n    return {\n        id,\n        type: \"Feature\",\n        properties: {\n            isCircle: true,\n            center,\n            radius: circleRadius,\n        },\n        geometry: {\n            type: \"Polygon\",\n            coordinates: circleFeature.geometry.coordinates,\n        },\n    };\n};\nconst getDistanceFromBounds = (bounds) => {\n    const swCoordinate = bounds.getSouthWest().toArray();\n    const neCoordinate = bounds.getNorthEast().toArray();\n    const center = bounds.getCenter().toArray();\n    const line = lineString([swCoordinate, center, neCoordinate]);\n    return length(line, { units: \"miles\" });\n};\nexport const doesGeofenceExist = (id, loadedGeofences) => {\n    return !!loadedGeofences[id];\n};\nexport const isValidGeofenceId = (id) => {\n    return !!id.match(GEOFENCE_ID_REGEX);\n};\nexport const isExistingGeofenceId = (id, loadedGeofences) => {\n    return doesGeofenceExist(id, loadedGeofences);\n};\nexport const isGeofenceDisplayed = (id, displayedGeofences) => {\n    return !!displayedGeofences.find((geofence) => geofence.geofenceId === id);\n};\nexport const getDistanceBetweenCoordinates = (startCoord, endCoord) => {\n    const line = lineString([startCoord, endCoord]);\n    const distanceInMiles = length(line, { units: \"miles\" });\n    return distanceInMiles;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}